'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const jsxRuntime = require('react/jsx-runtime');
const react = require('react');

const Component = ({ as: Element = "div", ...props }, ref) => {
  return /* @__PURE__ */ jsxRuntime.jsx(Element, { ...props, ref });
};
const Container = react.forwardRef(Component);

const SCRIPT_URL = "https://challenges.cloudflare.com/turnstile/v0/api.js";
const DEFAULT_SCRIPT_ID = "cf-turnstile-script";
const DEFAULT_CONTAINER_ID = "cf-turnstile";
const DEFAULT_ONLOAD_NAME = "onloadTurnstileCallback";
const checkElementExistence = (id) => !!document.getElementById(id);
const injectTurnstileScript = ({
  render = "explicit",
  onLoadCallbackName = DEFAULT_ONLOAD_NAME,
  scriptOptions: {
    nonce = "",
    defer = true,
    async = true,
    id = "",
    appendTo,
    onError,
    crossOrigin = ""
  } = {}
}) => {
  const scriptId = id || DEFAULT_SCRIPT_ID;
  if (checkElementExistence(scriptId)) {
    return;
  }
  const script = document.createElement("script");
  script.id = scriptId;
  script.src = `${SCRIPT_URL}?onload=${onLoadCallbackName}&render=${render}`;
  if (document.querySelector(`script[src="${script.src}"]`)) {
    return;
  }
  script.defer = !!defer;
  script.async = !!async;
  if (nonce) {
    script.nonce = nonce;
  }
  if (crossOrigin) {
    script.crossOrigin = crossOrigin;
  }
  if (onError) {
    script.onerror = onError;
    delete window[onLoadCallbackName];
  }
  const parentEl = appendTo === "body" ? document.body : document.getElementsByTagName("head")[0];
  parentEl.appendChild(script);
};
const CONTAINER_STYLE_SET = {
  normal: {
    width: 300,
    height: 65
  },
  compact: {
    width: 130,
    height: 120
  },
  invisible: {
    width: 0,
    height: 0,
    overflow: "hidden"
  },
  auto: {},
  interactionOnly: {
    width: "fit-content",
    height: "auto",
    display: "flex"
  }
};
function getTurnstileSizeOpts(size) {
  let result;
  if (size !== "invisible" && size !== "auto") {
    result = size;
  }
  return result;
}

function useObserveScript(scriptId = DEFAULT_SCRIPT_ID) {
  const [scriptLoaded, setScriptLoaded] = react.useState(false);
  react.useEffect(() => {
    const checkScriptExists = () => {
      if (checkElementExistence(scriptId)) {
        setScriptLoaded(true);
      }
    };
    const observer = new MutationObserver(checkScriptExists);
    observer.observe(document, { childList: true, subtree: true });
    checkScriptExists();
    return () => {
      observer.disconnect();
    };
  }, [scriptId]);
  return scriptLoaded;
}

let turnstileState = "unloaded";
let turnstileLoad;
const turnstileLoadPromise = new Promise((resolve, reject) => {
  turnstileLoad = { resolve, reject };
  if (turnstileState === "ready")
    resolve(void 0);
});
const ensureTurnstile = (onLoadCallbackName = DEFAULT_ONLOAD_NAME) => {
  if (turnstileState === "unloaded") {
    turnstileState = "loading";
    window[onLoadCallbackName] = () => {
      turnstileLoad.resolve();
      turnstileState = "ready";
      delete window[onLoadCallbackName];
    };
  }
  return turnstileLoadPromise;
};
const Turnstile = react.forwardRef((props, ref) => {
  const {
    scriptOptions,
    options = {},
    siteKey,
    onWidgetLoad,
    onSuccess,
    onExpire,
    onError,
    onBeforeInteractive,
    onAfterInteractive,
    onUnsupported,
    onLoadScript,
    id,
    style,
    as = "div",
    injectScript = true,
    ...divProps
  } = props;
  const widgetSize = options.size || "normal";
  const [containerStyle, setContainerStyle] = react.useState(
    options.execution === "execute" ? CONTAINER_STYLE_SET.invisible : options.appearance === "interaction-only" ? CONTAINER_STYLE_SET.interactionOnly : CONTAINER_STYLE_SET[widgetSize]
  );
  const containerRef = react.useRef(null);
  const [turnstileLoaded, setTurnstileLoaded] = react.useState(false);
  const widgetId = react.useRef();
  const widgetSolved = react.useRef(false);
  const containerId = id || DEFAULT_CONTAINER_ID;
  const scriptId = scriptOptions?.id || DEFAULT_SCRIPT_ID;
  const scriptLoaded = useObserveScript(scriptId);
  const onLoadCallbackName = scriptOptions?.onLoadCallbackName || DEFAULT_ONLOAD_NAME;
  const appearance = options.appearance || "always";
  const renderConfig = react.useMemo(
    () => ({
      sitekey: siteKey,
      action: options.action,
      cData: options.cData,
      callback: (token) => {
        widgetSolved.current = true;
        onSuccess?.(token);
      },
      "error-callback": onError,
      "expired-callback": onExpire,
      "before-interactive-callback": onBeforeInteractive,
      "after-interactive-callback": onAfterInteractive,
      "unsupported-callback": onUnsupported,
      theme: options.theme || "auto",
      language: options.language || "auto",
      tabindex: options.tabIndex,
      "response-field": options.responseField,
      "response-field-name": options.responseFieldName,
      size: getTurnstileSizeOpts(widgetSize),
      retry: options.retry || "auto",
      "retry-interval": options.retryInterval || 8e3,
      "refresh-expired": options.refreshExpired || "auto",
      execution: options.execution || "render",
      appearance: options.appearance || "always"
    }),
    [
      options.action,
      options.appearance,
      options.cData,
      options.execution,
      options.language,
      options.refreshExpired,
      options.responseField,
      options.responseFieldName,
      options.retry,
      options.retryInterval,
      options.tabIndex,
      options.theme,
      siteKey,
      widgetSize
    ]
  );
  const checkIfTurnstileLoaded = react.useCallback(() => {
    return typeof window !== "undefined" && !!window.turnstile;
  }, []);
  react.useEffect(
    function inject() {
      if (injectScript && !turnstileLoaded) {
        injectTurnstileScript({
          onLoadCallbackName,
          scriptOptions: {
            ...scriptOptions,
            id: scriptId
          }
        });
      }
    },
    [injectScript, turnstileLoaded, scriptOptions, scriptId]
  );
  react.useEffect(function waitForTurnstile() {
    if (turnstileState !== "ready") {
      ensureTurnstile(onLoadCallbackName).then(() => setTurnstileLoaded(true)).catch(console.error);
    }
  }, []);
  react.useEffect(
    function renderWidget() {
      if (!containerRef.current)
        return;
      if (!turnstileLoaded)
        return;
      let cancelled = false;
      const render = async () => {
        if (cancelled || !containerRef.current)
          return;
        const id2 = window.turnstile.render(containerRef.current, renderConfig);
        widgetId.current = id2;
        if (widgetId.current)
          onWidgetLoad?.(widgetId.current);
      };
      render();
      return () => {
        cancelled = true;
        if (widgetId.current)
          window.turnstile.remove(widgetId.current);
      };
    },
    [containerId, turnstileLoaded, renderConfig]
  );
  react.useImperativeHandle(
    ref,
    () => {
      const { turnstile } = window;
      return {
        getResponse() {
          if (!turnstile?.getResponse || !widgetId.current || !checkIfTurnstileLoaded()) {
            console.warn("Turnstile has not been loaded");
            return;
          }
          return turnstile.getResponse(widgetId.current);
        },
        async getResponsePromise(timeout = 3e4, retry = 100) {
          return new Promise((resolve, reject) => {
            let timeoutId;
            const checkLoaded = async () => {
              if (widgetSolved.current && window.turnstile && widgetId.current) {
                try {
                  const token = window.turnstile.getResponse(widgetId.current);
                  if (timeoutId)
                    clearTimeout(timeoutId);
                  if (token) {
                    return resolve(token);
                  }
                  return reject(new Error("No response received"));
                } catch (error) {
                  if (timeoutId)
                    clearTimeout(timeoutId);
                  console.warn("Failed to get response", error);
                  return reject(new Error("Failed to get response"));
                }
              }
              if (!timeoutId) {
                timeoutId = setTimeout(() => {
                  if (timeoutId)
                    clearTimeout(timeoutId);
                  reject(new Error("Timeout"));
                }, timeout);
              }
              await new Promise((resolve2) => setTimeout(resolve2, retry));
              await checkLoaded();
            };
            checkLoaded();
          });
        },
        reset() {
          if (!turnstile?.reset || !widgetId.current || !checkIfTurnstileLoaded()) {
            console.warn("Turnstile has not been loaded");
            return;
          }
          if (options.execution === "execute") {
            setContainerStyle(CONTAINER_STYLE_SET.invisible);
          }
          try {
            widgetSolved.current = false;
            turnstile.reset(widgetId.current);
          } catch (error) {
            console.warn(`Failed to reset Turnstile widget ${widgetId}`, error);
          }
        },
        remove() {
          if (!turnstile?.remove || !widgetId.current || !checkIfTurnstileLoaded()) {
            console.warn("Turnstile has not been loaded");
            return;
          }
          setContainerStyle(CONTAINER_STYLE_SET.invisible);
          widgetSolved.current = false;
          turnstile.remove(widgetId.current);
          widgetId.current = null;
        },
        render() {
          if (!turnstile?.render || !containerRef.current || !checkIfTurnstileLoaded() || widgetId.current) {
            console.warn("Turnstile has not been loaded or container not found");
            return;
          }
          const id2 = turnstile.render(containerRef.current, renderConfig);
          widgetId.current = id2;
          if (widgetId.current)
            onWidgetLoad?.(widgetId.current);
          if (options.execution !== "execute") {
            setContainerStyle(CONTAINER_STYLE_SET[widgetSize]);
          }
          return id2;
        },
        execute() {
          if (options.execution !== "execute") {
            console.warn('Execution mode is not set to "execute"');
            return;
          }
          if (!turnstile?.execute || !containerRef.current || !widgetId.current || !checkIfTurnstileLoaded()) {
            console.warn("Turnstile has not been loaded or container not found");
            return;
          }
          turnstile.execute(containerRef.current, renderConfig);
          setContainerStyle(CONTAINER_STYLE_SET[widgetSize]);
        },
        isExpired() {
          if (!turnstile?.isExpired || !widgetId.current || !checkIfTurnstileLoaded()) {
            console.warn("Turnstile has not been loaded");
            return;
          }
          return turnstile.isExpired(widgetId.current);
        }
      };
    },
    [
      widgetId,
      options.execution,
      widgetSize,
      renderConfig,
      containerRef,
      checkIfTurnstileLoaded,
      turnstileLoaded,
      onWidgetLoad
    ]
  );
  react.useEffect(() => {
    if (scriptLoaded && !turnstileLoaded && window.turnstile) {
      setTurnstileLoaded(true);
    }
  }, [turnstileLoaded, scriptLoaded]);
  react.useEffect(() => {
    setContainerStyle(
      options.execution === "execute" ? CONTAINER_STYLE_SET.invisible : appearance === "interaction-only" ? CONTAINER_STYLE_SET.interactionOnly : CONTAINER_STYLE_SET[widgetSize]
    );
  }, [options.execution, widgetSize, appearance]);
  react.useEffect(() => {
    if (!scriptLoaded || typeof onLoadScript !== "function")
      return;
    onLoadScript();
  }, [scriptLoaded]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    Container,
    {
      ref: containerRef,
      as,
      id: containerId,
      style: { ...containerStyle, ...style },
      ...divProps
    }
  );
});
Turnstile.displayName = "Turnstile";

exports.DEFAULT_CONTAINER_ID = DEFAULT_CONTAINER_ID;
exports.DEFAULT_ONLOAD_NAME = DEFAULT_ONLOAD_NAME;
exports.DEFAULT_SCRIPT_ID = DEFAULT_SCRIPT_ID;
exports.SCRIPT_URL = SCRIPT_URL;
exports.Turnstile = Turnstile;
